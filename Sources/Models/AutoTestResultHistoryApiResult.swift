//
// AutoTestResultHistoryApiResult.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct AutoTestResultHistoryApiResult: Codable, JSONEncodable, Hashable {

    public var id: UUID
    public var testPlanId: UUID?
    public var testPlanGlobalId: Int64?
    public var testPlanName: String?
    public var duration: Int64?
    public var testRunId: UUID
    public var testRunName: String?
    public var configurationId: UUID
    public var configurationName: String
    public var outcome: AutotestResultOutcome
    public var status: TestStatusApiResult
    public var launchSource: String?
    public var rerunCount: Int
    public var rerunTestResults: [RerunTestResultApiResult]
    public var createdDate: Date
    public var createdById: UUID
    public var createdByName: String?
    public var modifiedDate: Date?
    public var modifiedById: UUID?

    public init(id: UUID, testPlanId: UUID? = nil, testPlanGlobalId: Int64? = nil, testPlanName: String? = nil, duration: Int64? = nil, testRunId: UUID, testRunName: String? = nil, configurationId: UUID, configurationName: String, outcome: AutotestResultOutcome, status: TestStatusApiResult, launchSource: String? = nil, rerunCount: Int, rerunTestResults: [RerunTestResultApiResult], createdDate: Date, createdById: UUID, createdByName: String? = nil, modifiedDate: Date? = nil, modifiedById: UUID? = nil) {
        self.id = id
        self.testPlanId = testPlanId
        self.testPlanGlobalId = testPlanGlobalId
        self.testPlanName = testPlanName
        self.duration = duration
        self.testRunId = testRunId
        self.testRunName = testRunName
        self.configurationId = configurationId
        self.configurationName = configurationName
        self.outcome = outcome
        self.status = status
        self.launchSource = launchSource
        self.rerunCount = rerunCount
        self.rerunTestResults = rerunTestResults
        self.createdDate = createdDate
        self.createdById = createdById
        self.createdByName = createdByName
        self.modifiedDate = modifiedDate
        self.modifiedById = modifiedById
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case testPlanId
        case testPlanGlobalId
        case testPlanName
        case duration
        case testRunId
        case testRunName
        case configurationId
        case configurationName
        case outcome
        case status
        case launchSource
        case rerunCount
        case rerunTestResults
        case createdDate
        case createdById
        case createdByName
        case modifiedDate
        case modifiedById
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encodeIfPresent(testPlanId, forKey: .testPlanId)
        try container.encodeIfPresent(testPlanGlobalId, forKey: .testPlanGlobalId)
        try container.encodeIfPresent(testPlanName, forKey: .testPlanName)
        try container.encodeIfPresent(duration, forKey: .duration)
        try container.encode(testRunId, forKey: .testRunId)
        try container.encodeIfPresent(testRunName, forKey: .testRunName)
        try container.encode(configurationId, forKey: .configurationId)
        try container.encode(configurationName, forKey: .configurationName)
        try container.encode(outcome, forKey: .outcome)
        try container.encode(status, forKey: .status)
        try container.encodeIfPresent(launchSource, forKey: .launchSource)
        try container.encode(rerunCount, forKey: .rerunCount)
        try container.encode(rerunTestResults, forKey: .rerunTestResults)
        try container.encode(createdDate, forKey: .createdDate)
        try container.encode(createdById, forKey: .createdById)
        try container.encodeIfPresent(createdByName, forKey: .createdByName)
        try container.encodeIfPresent(modifiedDate, forKey: .modifiedDate)
        try container.encodeIfPresent(modifiedById, forKey: .modifiedById)
    }
}

