//
// WebHookPostModel.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

internal struct WebHookPostModel: Codable, JSONEncodable, Hashable {

    static let urlRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    static let nameRule = StringRule(minLength: 0, maxLength: 255, pattern: nil)
    /** Unique ID of the webhook project */
    internal var projectId: UUID
    /** Type of event which triggers the webhook */
    internal var eventType: WebHookEventTypeModel
    /** Description of the webhook */
    internal var description: String?
    /** Request URL of the webhook */
    internal var url: String
    /** Request method of the webhook */
    internal var requestType: RequestTypeModel
    /** Indicates if the webhook sends body */
    internal var shouldSendBody: Bool
    /** Collection of the webhook headers */
    internal var headers: [String: String]
    /** Collection of the webhook query parameters */
    internal var queryParameters: [String: String]
    /** Indicates if the webhook is active */
    internal var isEnabled: Bool
    /** Indicates if the webhook sends custom body */
    internal var shouldSendCustomBody: Bool
    /** Custom body of the webhook */
    internal var customBody: String?
    /** Indicates if the webhook injects parameters */
    internal var shouldReplaceParameters: Bool
    /** Indicates if the webhook escapes invalid characters in parameters */
    internal var shouldEscapeParameters: Bool
    /** Name of the webhook */
    internal var name: String

    internal init(projectId: UUID, eventType: WebHookEventTypeModel, description: String? = nil, url: String, requestType: RequestTypeModel, shouldSendBody: Bool, headers: [String: String], queryParameters: [String: String], isEnabled: Bool, shouldSendCustomBody: Bool, customBody: String? = nil, shouldReplaceParameters: Bool, shouldEscapeParameters: Bool, name: String) {
        self.projectId = projectId
        self.eventType = eventType
        self.description = description
        self.url = url
        self.requestType = requestType
        self.shouldSendBody = shouldSendBody
        self.headers = headers
        self.queryParameters = queryParameters
        self.isEnabled = isEnabled
        self.shouldSendCustomBody = shouldSendCustomBody
        self.customBody = customBody
        self.shouldReplaceParameters = shouldReplaceParameters
        self.shouldEscapeParameters = shouldEscapeParameters
        self.name = name
    }

    internal enum CodingKeys: String, CodingKey, CaseIterable {
        case projectId
        case eventType
        case description
        case url
        case requestType
        case shouldSendBody
        case headers
        case queryParameters
        case isEnabled
        case shouldSendCustomBody
        case customBody
        case shouldReplaceParameters
        case shouldEscapeParameters
        case name
    }

    // Encodable protocol methods

    internal func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(projectId, forKey: .projectId)
        try container.encode(eventType, forKey: .eventType)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encode(url, forKey: .url)
        try container.encode(requestType, forKey: .requestType)
        try container.encode(shouldSendBody, forKey: .shouldSendBody)
        try container.encode(headers, forKey: .headers)
        try container.encode(queryParameters, forKey: .queryParameters)
        try container.encode(isEnabled, forKey: .isEnabled)
        try container.encode(shouldSendCustomBody, forKey: .shouldSendCustomBody)
        try container.encodeIfPresent(customBody, forKey: .customBody)
        try container.encode(shouldReplaceParameters, forKey: .shouldReplaceParameters)
        try container.encode(shouldEscapeParameters, forKey: .shouldEscapeParameters)
        try container.encode(name, forKey: .name)
    }
}

